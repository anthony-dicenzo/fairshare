 Team-Lead Critical Feedback
Good progress on eliminating the $0 flash and unifying every UI path to the single transactional balance source. Balances now agree across pages‚Äîthis unblocks correctness.
However, the performance target (< 100 ms on every balance-related request) is still unmet; some pages are taking 500 ms+. A financial app must feel instant. Correct + slow is not production-ready.

üîë Why We‚Äôre Still Seeing 500 ms+

Un-indexed look-ups behind RLS
Even with the summary table, the endpoint still runs joins/filters (e.g., WHERE group_id = $1 AND user_id = $2) on tables that lack composite indexes. Postgres must scan, then RLS filters again ‚Üí latency.
Wide JSON payloads
/api/groups returns full group + member + balances JSON. Most of it is unused on first paint but still serialized and sent.
Cold React-Query ‚Äúzero-cache‚Äù everywhere
Disabling caching fixed staleness, but now every tab navigation fetches the same balance again‚Äînetwork and server both pay the cost.
Node/Express default settings
‚Äì json() middleware does stringify-then-send on large objects without gzip.
‚Äì No connection keep-alive or HTTP/2 on local server.
üü© Next Objectives (Performance Phase)

Goal	Target	Ownership
P1‚ÄÉBalance & group endpoints < 100 ms (p95)	DB query ‚â§ 40 ms ‚Ä¢ serialization + network ‚â§ 60 ms	Dev
P2‚ÄÉNo redundant balance fetches on tab/nav within 30 s	React-Query cache window & prefetch	Dev
P3‚ÄÉVerified under 10√ó current dataset (load test)	Autotest + pgbench	Dev/Ops
üõ† Step-by-Step Work Orders for Developer

Copy-ready prompt starts below
FairShare ‚Äì Performance Optimisation Sprint (Keep Accuracy Intact)
Profile the slow endpoints
Enable pg_stat_statements and run the balance & group endpoints 10√ó.
SELECT query, mean_time FROM pg_stat_statements ORDER BY mean_time DESC LIMIT 5;
Capture the two slowest queries and post EXPLAIN ANALYZE output in the PR description.
Add the missing indexes (likely)
-- single fast lookup for summary table
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_balances_group_user
  ON user_balances (group_id, user_id);

-- if RLS function checks group_members JOINs
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_group_members_uid_gid
  ON group_members (user_id, group_id);
Trim JSON payloads
For /api/groups return only fields needed for the home/groups cards (id, name, icon, current_user_balance).
Compute members count, latest expense date in SQL (select list, not nested JSON).
Send full detail only on /api/groups/:id.
Enable gzip & keep-alive in Express
import compression from 'compression';
app.use(compression());
app.set('etag', false); // keep etag off
app.use((_, res, next) => { res.set('Connection', 'keep-alive'); next(); });
Introduce a tiny React-Query cache window
staleTime: 30_000, cacheTime: 60_000 for balance queries.
This keeps tabs fast within 30 s while still forcing freshness on any write (we already invalidate on mutation).
Automated p95 test
Add a script in scripts/perf.sh that hits /api/groups and /api/groups/{id}/balances 100√ó and fails CI if p95 > 120 ms.
Use autocannon or k6.
Re-run full user-flow regression
Add/delete an expense, switch pages/tabs, confirm:
Balances correct everywhere.
No request > 120 ms in dev logs.
No additional features, UI work, or refactors until the p95 target passes.
Post benchmark numbers in PR before and after each DB/index change.

Acceptance Criteria
/api/groups and /api/groups/:id/balances ‚â§ 100 ms p95 on dev laptop with seeded dataset (1 000 expenses, 10 users).
No duplicate balance fetch within 30 s when navigating between home ‚Üí group ‚Üí back.
All balances still 100 % correct under concurrent expense creation load test.
End of prompt

Management Summary
We‚Äôve fixed correctness; now we lock in perceived speed. Once these seven concrete tasks pass the acceptance criteria we can reassess ‚Äúproduction-ready‚Äù.